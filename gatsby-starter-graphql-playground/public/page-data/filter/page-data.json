{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-graphql-playground-src-templates-item-tsx","path":"/filter","result":{"data":{"playground":{"slug":"/filter","query":"%7B%0A%20%20allMarkdownRemark(filter:%20%7B%20frontmatter:%20%7B%20title:%20%7B%20ne:%20%22%22%20%7D%20%7D%20%7D)%20%7B%0A%20%20%20%20totalCount%0A%20%20%20%20edges%20%7B%0A%20%20%20%20%20%20node%20%7B%0A%20%20%20%20%20%20%20%20frontmatter%20%7B%0A%20%20%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Filter\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\",\n    \"metastring\": \"preview\",\n    \"preview\": true\n  }, \"{\\n  allMarkdownRemark(filter: { frontmatter: { title: { ne: \\\"\\\" } } }) {\\n    totalCount\\n    edges {\\n      node {\\n        frontmatter {\\n          title\\n        }\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"In this query \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"filter\"), \" and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ne\"), \" (not equals) operator is used to show only results that have a title. You can find a good video tutorial on this \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=Lg1bom99uGM\"\n  }, \"here\"), \".\"), mdx(\"p\", null, \"Gatsby relies on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.npmjs.com/package/sift\"\n  }, \"Sift\"), \" to enable MongoDB-like query syntax for object filtering. This allows Gatsby to support operators like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"eq\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ne\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"in\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"regex\"), \" and querying nested fields through the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__\"), \" connector.\"), mdx(\"p\", null, \"It is also possible to filter on multiple fields - just separate the individual filters by a comma (works as an AND):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"filter: { contentType: { in: [\\\"post\\\", \\\"page\\\"] }, draft: { eq: false } }\\n\")), mdx(\"h2\", null, \"Complete list of possible operators\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"eq\"), \": short for \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"equal\"), \", must match the given data exactly\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ne\"), \": short for \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"not equal\"), \", must be different from the given data\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"regex\"), \": short for \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"regular expression\"), \", must match the given pattern. Note that backslashes need to be escaped \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"twice\"), \", so \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"/\\\\w+/\"), \" needs to be written as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\\"/\\\\\\\\\\\\\\\\w+/\\\"\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"glob\"), \": short for \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"global\"), \", allows to use wildcard \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"*\"), \" which acts as a placeholder for any non-empty string\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"in\"), \": short for \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"in array\"), \", must be an element of the array\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"nin\"), \": short for \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"not in array\"), \", must NOT be an element of the array\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gt\"), \": short for \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"greater than\"), \", must be greater than given value\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gte\"), \": short for \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"greater than or equal\"), \", must be greater than or equal to given value\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"lt\"), \": short for \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"less than\"), \", must be less than given value\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"lte\"), \": short for \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"less than or equal\"), \", must be less than or equal to given value\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"elemMatch\"), \": short for \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"element match\"), \", this indicates that the field you are filtering will return an array of elements, on which you can apply a filter using the previous operators\")), mdx(\"p\", null, \"If you want to understand more how these filters work, looking at the corresponding \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/__tests__/run-query.js\"\n  }, \"tests\"), \" in the codebase could be very useful.\"));\n}\n;\nMDXContent.isMDXComponent = true;","title":"Filter"}},"pageContext":{"slug":"/filter"}},"staticQueryHashes":["2744905544","3181798408"]}